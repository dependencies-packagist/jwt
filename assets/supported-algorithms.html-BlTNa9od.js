import{_ as d,c as e,a as o,o as a}from"./app-B9Ka1KbF.js";const c={};function r(n,t){return a(),e("div",null,t[0]||(t[0]=[o('<h1 id="签名算法" tabindex="-1"><a class="header-anchor" href="#签名算法"><span>签名算法</span></a></h1><p>本库支持使用对称算法和非对称算法对令牌进行签名和验证。 <strong>目前尚不支持加密功能。</strong> 每种算法生成的签名长度不同。如果你对生成令牌的长度有要求，建议选择生成签名较短的算法（如 <code>HS256</code>、<code>RS256</code> 和 <code>ES256</code>）。</p><h2 id="对称算法-symmetric-algorithms" tabindex="-1"><a class="header-anchor" href="#对称算法-symmetric-algorithms"><span>对称算法（Symmetric algorithms）</span></a></h2><p>对称算法在签名创建和验证过程中使用的是同一把密钥/秘钥。 适用于签名和验证都由同一个组件处理的场景。</p><table><thead><tr><th>名称</th><th>描述</th><th>类名</th><th>密钥长度要求</th></tr></thead><tbody><tr><td><code>HS256</code></td><td>基于 SHA-256 的 HMAC</td><td><code>\\Token\\JWT\\Signature\\Hmac\\HS256</code></td><td><code>&gt;= 256 bits</code></td></tr><tr><td><code>HS384</code></td><td>基于 SHA-384 的 HMAC</td><td><code>\\Token\\JWT\\Signature\\Hmac\\HS384</code></td><td><code>&gt;= 384 bits</code></td></tr><tr><td><code>HS512</code></td><td>基于 SHA-512 的 HMAC</td><td><code>\\Token\\JWT\\Signature\\Hmac\\HS512</code></td><td><code>&gt;= 512 bits</code></td></tr></tbody></table><h2 id="非对称算法-asymmetric-algorithms" tabindex="-1"><a class="header-anchor" href="#非对称算法-asymmetric-algorithms"><span>非对称算法（Asymmetric algorithms）</span></a></h2><p>非对称算法使用 <code>私钥/密钥</code> 进行签名创建，使用 <code>公钥</code> 进行签名验证。 适用于由一个组件创建令牌，而多个组件进行验证的场景。</p><table><thead><tr><th>名称</th><th>描述</th><th>类名</th><th>密钥长度要求</th></tr></thead><tbody><tr><td><code>ES256</code></td><td>使用 P-256 和 SHA-256 的 ECDSA 签名算法</td><td><code>\\Token\\JWT\\Signature\\Ecdsa\\ES256</code></td><td><code>== 256 bits</code></td></tr><tr><td><code>ES384</code></td><td>使用 P-256 和 SHA-256 的 ECDSA 签名算法</td><td><code>\\Token\\JWT\\Signature\\Ecdsa\\ES384</code></td><td><code>== 384 bits</code></td></tr><tr><td><code>ES512</code></td><td>使用 P-256 和 SHA-256 的 ECDSA 签名算法</td><td><code>\\Token\\JWT\\Signature\\Ecdsa\\ES512</code></td><td><code>== 521 bits</code></td></tr><tr><td><code>RS256</code></td><td>使用 SHA-256 的 RSASSA-PKCS1-v1_5 签名算法</td><td><code>\\Token\\JWT\\Signature\\Rsa\\RS256</code></td><td><code>&gt;= 2048 bits</code></td></tr><tr><td><code>RS384</code></td><td>使用 SHA-256 的 RSASSA-PKCS1-v1_5 签名算法</td><td><code>\\Token\\JWT\\Signature\\Rsa\\RS384</code></td><td><code>&gt;= 2048 bits</code></td></tr><tr><td><code>RS512</code></td><td>使用 SHA-256 的 RSASSA-PKCS1-v1_5 签名算法</td><td><code>\\Token\\JWT\\Signature\\Rsa\\RS512</code></td><td><code>&gt;= 2048 bits</code></td></tr><tr><td><code>EdDSA</code></td><td>EdDSA 签名算法</td><td><code>\\Token\\JWT\\Signature\\Eddsa</code></td><td><code>&gt;= 256 bits</code></td></tr></tbody></table><h2 id="适用于未使用任何签名算法的情况-即-alg-none" tabindex="-1"><a class="header-anchor" href="#适用于未使用任何签名算法的情况-即-alg-none"><span>适用于未使用任何签名算法的情况（即 alg: none）</span></a></h2><p><code>none</code> 算法（如 <a href="https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms" target="_blank" rel="noopener noreferrer">JWT 标准</a> 中所述）未实现也不被支持。 因为其被滥用的风险极高，即便存在其他机制确保令牌的有效性，在现代硬件环境下，使用对称算法也不应构成性能瓶颈。</p>',10)]))}const i=d(c,[["render",r]]),h=JSON.parse('{"path":"/zh/introduction/supported-algorithms.html","title":"签名算法","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"对称算法（Symmetric algorithms）","slug":"对称算法-symmetric-algorithms","link":"#对称算法-symmetric-algorithms","children":[]},{"level":2,"title":"非对称算法（Asymmetric algorithms）","slug":"非对称算法-asymmetric-algorithms","link":"#非对称算法-asymmetric-algorithms","children":[]},{"level":2,"title":"适用于未使用任何签名算法的情况（即 alg: none）","slug":"适用于未使用任何签名算法的情况-即-alg-none","link":"#适用于未使用任何签名算法的情况-即-alg-none","children":[]}],"git":{"updatedTime":1744722100000,"contributors":[{"name":"jundayw","username":"jundayw","email":"jundayw@126.com","commits":1,"url":"https://github.com/jundayw"}],"changelog":[{"hash":"becee0cfa39dcfe36fa0ba62a945435dc33913fc","time":1744722100000,"email":"jundayw@126.com","author":"jundayw","message":"docs:Supported Algorithms"}]},"filePathRelative":"zh/introduction/supported-algorithms.md"}');export{i as comp,h as data};
